---
MEP: 3
Title: UI elements
Discussion: XXX
Implementation: XXX
---

# UI Elements

## Abstract

This MEP lays out a design for a user interface (UI) module, `marimo.ui`, which
provides a library of pre-fabricated UI elements that programmers
can use in their apps. The main concerns of the design are:

- a UI element as an HTML element with a value
- syntax for accessing a UI element's value
- syncronizing a UI element's appearance when it is shown multiple times
  within an app
- synchronizing a UI element's value in the frontend with its value in the
  kernel
- a simple rule that determines which cells are run when a UI element is interacted with
- a simple mechanism for making custom elements

## Motivation

Marimo stands out from traditional paradigms for interactive computing in a few
important ways: it is *reactive*, functioning like a spreadsheet,
*interactive*, with UI elements rendered in one cell able to seamlessly control
the execution of other cells via reactivity, and *extensible*, with the ability
to make custom UI elements as well as make any Python object render as a UI
element. While some open-source libraries and commercial editing tools provide
subsets of this functionality in ad-hoc ways, to our knowledge no tool like
marimo (open-source or otherwise) exists for Python developers. In particular,
no tool provides a pure Python experience, in which both experiments and
applications are built using an extensible, modular, and composable programming
framework.

Enabling data scientists to build powerful apps is one of marimo's twin
purposes. For this reason, it is critical that marimo's support for UI elements
is carefully designed.

## Criteria
We strive for a design that satisfies the following criteria:

- *seamless*: accessing a UI element's value must be seamless; no callbacks
- *simple*: a simple rule should explain what cells are run when a UI element is interacted with
- *Pythonic*: creating, displaying, and reading UI elements should be Pythonic
- *no web programming*: 99% of users shouldn't need to write any HTML,
                        Javascript, or CSS
- *customizable*: styling of UI elements should be customizable with CSS
- *extensible*: it should be easy for developers to implement custom UI
  elements, using web technologies of their choice

## UI elements: HTML objects with values
A UI element is an HTML element that has a _value_.
Its value may change when interacted with.

Many HTML elements do not have values; for example, markdown, or plain
text, or embedded videos, are just content. A UI element is different: for
example, a slider has a numeric value, a text form has a string value, and a
file upload box has a bytes value. This distinction is important enough to
merit the creation of a type specific to UI elements.

### The `UIElement` type

A `UIElement` is an `HTML` element that has a `value` attribute. This value can
be set at creation time by the user, to designate a default value for the
element; after creation, `value` cannot be changed by Python code.

The frontend can render the same `UIElement` multiple times, with multiple
instances of the same element tied together via a unique key. These rendered
elements may choose to update their values at any time, but typically their
values will only change upon user interaction.

**Frontend synchronization.** When the value of a rendered `UIElement` changes,
all other instances of the element that are rendered in the frontend have their
value updated as well. This ensures that the frontend remains consistent.

**Kernel synchronization**. 
When a rendered `UIElement`s value changes, the frontend sends a value update
request to the kernel; the kernel is then responsible for updating the `value`
attribute on the Python object corresponding to the element. When this
happens, the kernel wil run certain cells that depend on the `UIElement`
object, enbling user interaction to drive execution of other cells.
The rule for which cells are run is described in the next section.

## Runtime Ruleset

A single rule determines which cells will run after a `UIElement` is interacted
with: any cell referring to one or more of the names bound to a `UIElement`
will be run whenever a UI Element sends a value to the kernel. By
"referring", we mean that the cell has a name bound to the element among its
_refs_.

### Examples
**A simple example.**

> cell a
```python
text = mo.ui.text()
text
```

> cell b
```python
text.value
```

> cell c
```python
str(text)
```

Interacting with the UI element in `cell a` will cause cells `b` and `c` to
run, since `text` is a name bound to the element, and cells `b` and `c` both
have `text` among its refs. Cell `a` will _not_ run, because it has `text`
among its defs, not its refs.


**Constructor cells.**

An interaction will never cause a cell that creates the interacted-with
`UIElement` to run, since the constructing cell will never have the element's
name(s) among its refs. We saw this in the above example.

This is a desirable consequence of the ruleset, for if a cell that created the
`UIElement` were run upon interaction, then the `UIElement` would be
reconstructed and re-initialized with its default value, which would
effectively undo the effect of interacting with the element, making interaction
pointless. However, in some cases, this behavior may be surprising. For example:


> cell a
```python
# this cell won't do what its author wanted it to do ...
slider = mo.ui.slider(start=1, stop=10)
x = slider.value
```

> cell b
```python
slider
```

Interacting with the emitted slider will _not_ update the value of `x`. To
prevent confusion, we raise an exception at runtime when a
`UIElement`'s value is accessed in the cell that created it. In particular,
line `2` of cell `a` would raise an exception.

**Cells that reference and output a UI element.**

Let `element` be a `UIElement` in the cell

> cell a
```
element
```

Interacting with its output will trigger execution of `a`. In most cases this
execution will be unneeded, but harmless, since cells should be idempotent;
performance optimizations in the kernel and frontend can lessen the 
wasted computation (for example, we may choose to only send outputs to the
frontend when the output has changed).

In other cases, re-execution of the cell is in fact intended, as in cell `b` in
the below example:

> cell a
```python
text = mo.ui.text()
```

> cell b:
```python
contents = text.value
text, contents
```


**Unnamed `UIElement`s.**

If a `UIElement` does not have a name, then interacting with it will not
trigger execution of other cells, no matter where the element is used.

For example:

> cell a
```python
l = [mo.ui.text()]
l
```

> cell b
```python
l[0].value
```

Interacting with `l`'s stored text element in `cell a` will _not_ cause `cell
b` to run, because the text element is unnamed: `l[0]` is not a name bound to a
`UIElement` object, instead it is an expression that evaluates to a `UIElement`
at runtime.

_Traversing pointers?_
In the future, we may consider traversing pointers to discover where unnamed
`UIElement`s are used, and run those cells as well; however, this may
lead to what appears to be "action at a distance" when a `UIElement`
is heavily nested or hidden within the internals of some object. For now,
we will provide library functions that wrap common data structures. For example,
the above example could be rewritten as

> cell a
```python
l = mo.ui.list([mo.ui.text()])
l
```

> cell b
```python
l.value[0]
```

and interacting with `l` would now execute `b`, as desired.

XXX got here
## Library of Included Elements

An important subclass of UI elements are the [HTML input
elements](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input).
These are UI elements the modern browsers provide out-of-the-box, and can be
constructed with just a few lines of HTML.

Every input element has a [value
attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#value)
that stores its current value; some have special attributes (such as 'checked'
for checkboxes) that contain additional information. An input event is fired
whenever the value is changed.

#### Input elements

**Slider.** A numeric slider that displays the currently selected number.

**Number.** A field for numbers that has increment/decrement buttons, a min
and max, and the ability to type in a number; typing in a number out of bounds
will display an error message.

**Text.** A single-line text input area.

**Text area.** A multi-line text input area.

**Toggle.** A single boolean switch.

**Checkbox.** A group of toggles, with any number being selectable.

**Radio.** A group of radio buttons, with at most one being selectable.

**Drop-down.** HTML select. 

**File upload.**

**Form.** A collection of UI elements, together with a submit button, whose
value is dict with an entry for each element. The value is only sent when the
submit button is clicked.

XXX

### Other UI elements

There are many other kinds of UI elements that are not input elements.
For example, a D3 visualization, an image with a bounding box selector, or
a webcam screenshotter are all UI elements but are not HTML input elements.
Their interactivity is not furnished by the browser, but by custom Javascript
code. Our design must have also support these other elements.

XXX: implement in separate .js/.ts file, package into a library? write raw
HTML/javascript in python?


## Implementation

### Implementing simple UI Elements within Python
**The `UIElement` class**. We introduce a `UIElement` class for elements
whose frontend code is simple enough to include as a string within Python.
This makes it very easy to create simple components, at the cost of being
unwieldy to develop more complex ones.

XXX how does the value show up in the HTML?
```python
class UIElement(formatting.MIME):
  def __init__(self, html: str, initial_value: Optional[Any] = None) -> None:
    self.html = html
    self._value = initial_value
    
  @property
  def value(self) -> Any:
    return self._value

  def __mime__(self) -> tuple[str, str]:
    return (
      "text/html",
       (
          f'<UIElement objectId="{id(self)}}">'
          + self.html
          + '</UIElement>'
       ),
    )
  
  def __format__(self, spec: str) -> str:
    del spec
    return formatting.as_html(*self.__mime__())
```
In a future MEP, we will introduce a mechanism for registering UI elements that
were implemented entirely outside of Python (using raw HTML and Javascript, or
frontend frameworks); in this mechanism, Python code will forward
arguments to the frontend instead of generating and sending HTML; the frontend
will then instantiate the requested component on the kernel's behalf.

**Generated HTML.** The HTML generated for a UI element is wrapped in a
special tag, `<UIElement>`. This element carries an attribute called
`objectId` which contains the Python object `id` of the corresponding
`UIElement` object.

The `objectId` attribute uniquely identifies a frontend UI element, and will be
used to synchronize the values of multiply rendered elements within the
frontend. It will also be used to identify which UI element in the kernel needs
to have its value updated upon interaction.

### 



### Frontend synchronization

### Kernel synchronization

**Kernel synchronization.**  The `object-id` attribute of the generated HTML
will be used to find the corresponding `UIElement` in the kernel, and to
trigger reactive execution of cells that refer to it.

_Debouncing._

**Writing custom UI elements.** XXX

_Including HTML and JavaScript as strings in Python._

XXX sending value to marimo

_Writing components with JavaScript/TypeScript, React, and other frameworks._

XXX sending args to component

XXX sending value to marimo


## Evaluation

XXX

## Alternatives considered

<table>
<th> Rerun cell if ... </th>
<th>UIElement's name is a ref</th>
<th>UIElement's value attribute is referenced</th>

<tr>
<td></td>
<td>Reruns the interacted with cell</td>
<td>Does not rerun the interacted with cell</td>
</tr>

<tr>
<td></td>
<td>Runs all cells that have name as a ref, even if they don't access its value.</td>
<td>Only runs cell if they access element's value.</td>
</tr>

<tr>
<td></td>
<td>Compatible with accessing UIElement's value without referencing the `value`
attr, such as via a cast or operator overload </td>
<td>Incompatible with accessing UIElement's value without referencing the
`value` attr.</td>
</tr>

<tr>
<td></td>
<td>Compatible with pointer traversal to discover unnamed UI elements.</td>
<td>Incompatible with pointer traversal to discover unnamed UI elements.</td>
</tr>

<tr>
<td></td>
<td>Easier to explain.</td>
<td>Easy to explain.</td>
</tr>
</table>

The only cost to relying on the name, instead of the value attribute, is
running cells that may not have needed to be rerun, especially including the
cell that was just interacted with. This can be a performance consideration
(which is okay), but it can also be a correctness consideration if the cell is
not idempotent, and was not meant to be rerun. However, in marimo, it is best
practice to make all cells idempotent --- you should be prepared for your
cells to be rerun at any time. If the refs are the same, you likely want to
the defs and the output to be the same.


**Never re-running the cell whose output was interacted with.**

**Traversing pointers to find unnamed UI elements.**

**Manually binding names to UI elements.**

## XXX Scratch

We would like a single API for all UI elements, for synchronizing them on the
frontend as well as communicating values back to Python.

The current implementation does one thing for certain kinds of inputs, and
another thing for other inputs (`setInputValue` and `getInputValue`). To me it
seems this logic should be pushed down into the individual `UIElements`: the
elements, not the marimo frontend, should decide how values are incorporated
into them.

That seems like  a reasonable premise. So starting with that premise ...
how _do_ we synchronize multiple instances of a UI element in the frontend, and
how do we communicate values back to Python?

**Case 1.** UIElements embedded in iframes. Then use `window.postMessage` 
to propagate a message up to the marimo frontend, and include whatever
information is needed to forward value to Python as well as sync with other
copies of the UI Element.

How does sync-ing with other copies of the UI Element work? Let's consider a
copy, meaning an iframe with some content inside it. We'll need to reach into
the iframe and set some attribute, or send it some sort of message, or
something, if that's possible (looks like it is possible to post a message to
an iframe: https://stackoverflow.com/questions/61548354/how-to-postmessage-into-iframe).

so, say a UI element is interacted with. it sends a message to the frontend
saying "i've been interacted with -- here's my id, here's my new value,  do
what you will with this information". the frontend picks up this message, then
(1) sends a new message to each copy of the element on the page, and (2) sends
the value to the Python kernel.

When a UI element's iframe receives a message (containing a new value) from the
main page, ... it needs to somehow notify the component that its value has been
updated. Maybe every UI element needs to be wrapped in a dummy <UIElement>
tag, and we dispatch an event on that tag. Or maybe we just set a value
attribute on the first element child, or something. Basically the HTML
needs to have _something_ we can either dispatch an event to or set an
attribute on (with a custom setter used to react to the value changing). This
_something_ needs to be contractually agreed upon.

**Case 2.** UIElements as custom web components. 


XXX simpler way to run scripts: https://stackoverflow.com/questions/2592092/executing-script-elements-inserted-with-innerhtml
