---
MEP: 3
Title: UI elements
Discussion: XXX
Implementation: XXX
---

# UI Elements

## Abstract

This MEP lays out a design for a user interface (UI) module, `marimo.ui`, which
provides a library of pre-fabricated UI elements that programmers
can use in their apps. The main concerns of the design are:

- a UI element as an HTML element with a value
- syntax for accessing a UI element's value
- syncronizing a UI element's appearance when it is shown multiple times
  within an app
- synchronizing a UI element's value in the frontend with its value in the
  kernel
- a simple rule that determines which cells are run when a UI element is interacted with
- a simple mechanism for making custom elements

## Motivation

Marimo stands out from traditional paradigms for interactive computing in a few
important ways: it is *reactive*, functioning like a spreadsheet,
*interactive*, with UI elements rendered in one cell able to seamlessly control
the execution of other cells via reactivity, and *extensible*, with the ability
to make custom UI elements as well as make any Python object render as a UI
element. While some open-source libraries and commercial editing tools provide
subsets of this functionality in ad-hoc ways, to our knowledge no tool like
marimo (open-source or otherwise) exists for Python developers. In particular,
no tool provides a pure Python experience, in which both experiments and
applications are built using an extensible, modular, and composable programming
framework.

Enabling data scientists to build powerful apps is one of marimo's twin
purposes. For this reason, it is critical that marimo's support for UI elements
is carefully designed.

## Criteria
We strive for a design that satisfies the following criteria:

- *seamless*: accessing a UI element's value must be seamless; no callbacks
- *simple*: a simple rule should explain what cells are run when a UI element is interacted with
- *Pythonic*: creating, displaying, and reading UI elements should be Pythonic
- *no web programming*: 99% of users shouldn't need to write any HTML,
                        Javascript, or CSS
- *customizable*: styling of UI elements should be customizable with CSS
- *extensible*: it should be easy for developers to implement custom UI
  elements, using web technologies of their choice

## UI elements: HTML objects with values
A UI element is an HTML element that has a _value_.
Its value may change when interacted with.

Many HTML elements do not have values; for example, markdown, or plain
text, or embedded videos, are just content. A UI element is different: for
example, a slider has a numeric value, a text form has a string value, and a
file upload box has a bytes value. This distinction is important enough to
merit the creation of a type specific to UI elements.

### The `UIElement` type

A `UIElement` is an `HTML` element that has a `value` attribute. This value can
be set at creation time by the user, to designate a default value for the
element; after creation, `value` cannot be changed by Python code.

The frontend can render the same `UIElement` multiple times, with multiple
instances of the same element tied together via a unique key. These rendered
elements may choose to update their values at any time, but typically their
values will only change upon user interaction.

**Frontend synchronization.** When the value of a rendered `UIElement` changes,
all other instances of the element that are rendered in the frontend have their
value updated as well. This ensures that the frontend remains consistent.

**Kernel synchronization**. 
When a rendered `UIElement`s value changes, the frontend sends a value update
request to the kernel; the kernel is then responsible for updating the `value`
attribute on the Python object corresponding to the element. When this
happens, the kernel wil run certain cells that depend on the `UIElement`
object, enbling user interaction to drive execution of other cells.
The rule for which cells are run is described in the next section.

## A Runtime Rule

A single rule determines which cells will run after a `UIElement` is interacted
with: any cell referring to one or more of the names bound to a `UIElement`
will be run whenever a UI Element sends a value to the kernel. By
"referring", we mean that the cell has a name bound to the element among its
_refs_.

### Examples
**A simple example.**

> cell a
```python
text = mo.ui.text()
text
```

> cell b
```python
text.value
```

> cell c
```python
str(text)
```

Interacting with the UI element in `cell a` will cause cells `b` and `c` to
run, since `text` is a name bound to the element, and cells `b` and `c` both
have `text` among its refs. Cell `a` will _not_ run, because it has `text`
among its defs, not its refs.


**Constructor cells.**

An interaction will never cause a cell that creates the interacted-with
`UIElement` to run, since the constructing cell will never have the element's
name(s) among its refs. We saw this in the above example.

This is a desirable consequence of the ruleset, for if a cell that created the
`UIElement` were run upon interaction, then the `UIElement` would be
reconstructed and re-initialized with its default value, which would
effectively undo the effect of interacting with the element, making interaction
pointless. However, in some cases, this behavior may be surprising. For example:


> cell a
```python
# this cell won't do what its author wanted it to do ...
slider = mo.ui.slider(start=1, stop=10)
x = slider.value
```

> cell b
```python
slider
```

Interacting with the emitted slider will _not_ update the value of `x`. To
prevent confusion, we raise an exception at runtime when a
`UIElement`'s value is accessed in the cell that created it. In particular,
line `2` of cell `a` would raise an exception.

**Cells that reference and output a UI element.**

Let `element` be a `UIElement` in the cell

> cell a
```
element
```

Interacting with its output will trigger execution of `a`. In most cases this
execution will be unneeded, but harmless, since cells should be idempotent;
performance optimizations in the kernel and frontend can lessen the 
wasted computation (for example, we may choose to only send outputs to the
frontend when the output has changed).

In other cases, re-execution of the cell is in fact intended, as in cell `b` in
the below example:

> cell a
```python
text = mo.ui.text()
```

> cell b:
```python
contents = text.value
text, contents
```


**Unnamed `UIElement`s.**

If a `UIElement` does not have a name, then interacting with it will not
trigger execution of other cells, no matter where the element is used.

For example:

> cell a
```python
l = [mo.ui.text()]
l
```

> cell b
```python
l[0].value
```

Interacting with `l`'s stored text element in `cell a` will _not_ cause `cell
b` to run, because the text element is unnamed: `l[0]` is not a name bound to a
`UIElement` object, instead it is an expression that evaluates to a `UIElement`
at runtime.

_Traversing pointers?_
One might consider traversing pointers (via `gc.get_referrers()`) to discover
where unnamed `UIElement`s are used, and run those cells as well; however, this
may lead to what appears to be "action at a distance" when a `UIElement` is
heavily nested or hidden within the internals of some object. Moreover,
it is possible for `gc.get_referrers()` to miss some objects, if those
objects don't support garbage collection, though in practice this will rarely happen.

Given the extra complexity that traversing pointers would add to the ruleset
and implementation, we have decided against this path. Instead, we will provide
library functions that wrap common data structures. For example, the previous
example involving a list could be rewritten as

> cell a
```python
l = mo.ui.list([mo.ui.text()])
l
```

> cell b
```python
l.value[0]
```

Interacting with `l` would now execute `b`, as desired. If this proves
to be too cumbersome or confusing, we may consider extending the ruleset to
include unnamed UI elements.

## Library of Included Elements

The `marimo` library will ship with a library of pre-fabricated UI elements.
These elements will be made available through the module `marimo.ui`. Some
examples of basic elements include a numeric slider, number picker, text box,
checkbox, radio button and radio group, drop-down menu, file upload, and
button. Additional elements may include data structure elements, like a list,
dictionary, and set.

We defer the design of `marimo.ui` to a future MEP.
## Implementation 

### The `ui-element` tag

We define a custom HTML tag, `<ui-element>`, for rendering and sychronizing
UI elements on the page and with the kernel; this tag is registered as a
custom element. A `<ui-element>` wraps a single container element at
which the UI element is root.

**Object ID.**
A `ui-element` has a single attribute, `object-id`, which
uniquely identifies a `UIElement` object in the Python kernel. There may
be multiple `<ui-elements>` on the page with the same object id, if the same
element is shown multiple times on the page.

**Communication.** The `ui-element`'s child sends a custom event,
`marimo-value-input`, when its value has been updated:

```typescript
type marimoValueInputEventType = CustomEvent<{ value: any }>;
```

In response, the `<ui-element>` sends a `marimo-value-update` event
to all other objects sharing its object id to inform them that their values need
to be updated:

```typescript
type marimoValueUpdateEventType = CustomEvent<{ value: any }>;
```

It also sends a message to the kernel, informing it to send a value update
request to the Python kernel. The value is encoded in JSON before it is sent.

#### UI elements as custom web components

We implement the elements provided in `marimo.ui` as custom web components
(*e.g.*, `<marimo-slider start="1" stop="10" step="2"></marimo-slider>`)
that render their content in a shadow DOM. This has the following advantages:

- Styles are isolated from the editor.
- The implementation of the UI element is separate from the editor code,
  and is framework agnostic --- _i.e._, elements can be implemented using any
  web technology or framework.
- UI elements are easily composed using slots.
- UI elements are easy instantiate from Python --- we simply send over
  an HTML tag with attributes encoding the arguments of the UI element, and the
  browser handles their instantiation on our behalf.
- Using simple web components provides a simple path for others to implement
  their own UI elements and register them with marimo, though care must be
  taken to ensure that no name is registered more than once.

**UI elements are not sandboxed.**
We note that UI elements are _not_ isolated from the main document: 
they may read and modify anything on the page, though in the vast majority of
cases it would be good practice for them to not do so. This is a conscious
choice, since the alternatives are either too restrictive (such as rendering
all UI elements in sandboxed iframes) or cumbersome (serving UI elements from
different origins). Ultimately, `marimo` embraces end-user programming, and
we don't want to impose undue limitations on what users can do.

Just as users must exercise judgment on whether a Python library is safe for
them to use, they must also make sure to only use UI elements that they trust.
Of course, if the user trusts `marimo`, then they can trust the elements in the
`marimo.ui` module. Care must be taken when deploying marimo apps to ensure
that CSRF attack vectors aren't present.



### The Python `UIElement` class

We introduce a `UIElement` class that wraps html text in a `<ui-element>` tag and
registers the element with the kernel. This class has a read-only property
`value` for accessing the element's current value.

To create a `UIElement`, one subclasses this class, build the html string
from constructor parameters, and optionally implements a `_set_value`
method that sets the value of the element given the result of parsing the JSON
value update. This API is not yet public.

For example, here is a prototype implementation of a text element:

```python
class text(UIElement):
    def __init__(self, value: str = "", label: str = "") -> None:
        super().__init__(
            build_web_component(
                component_name="marimo-text",
                initial_value=value,
                args={"label": label},
            ),
            value,
        )
```

And a more interesting implementation of a button element:

```
class button(UIElement):
    @staticmethod
    def _on_click_noop() -> None:
        return None

    def __init__(
        self,
        on_click: Callable[[], Any] = _on_click_noop,
        value: Optional[Any] = None,
        label: str = "click",
    ) -> None:
        self._on_click = on_click
        super().__init__(
            build_web_component(
                component_name="marimo-button",
                initial_value=None,
                args={"label": label},
            ),
            None,
        )

    def _set_value(self, value: Any) -> None:
        del value
        self._value = self._on_click()
```

**Registering custom elements.**
In a future MEP, we will introduce a mechanism for registering UI elements that
were implemented entirely outside of Python. Once registered, these elements
will be able to be interfaced with Python by subclassing the `UIElement` class,
just like native elements.

## Evaluation

> - *seamless*: accessing a UI element's value must be seamless; no callbacks

- [x] An elements value is accessible through its value attribute.

> - *simple*: a simple rule should explain what cells are run when a UI element is interacted with

- [x] the rule is explained in one sentence: cells that ref the element are run

> - *Pythonic*: creating, displaying, and reading UI elements should be Pythonic

- [x] creating is just a function call, displaying is an output, reading a
      property read

> - *no web programming*: 99% of users shouldn't need to write any HTML,
                        Javascript, or CSS

- [x] marimo.ui provides prefabricated elements

> - *customizable*: styling of UI elements should be customizable with CSS

- [x] web components styles are isolated from the editor; an element's Python
  constructor could take custom styles to pass on to the frontend.

> - *extensible*: it should be easy for developers to implement custom UI
  elements, using web technologies of their choice

- [x] web components provide a simple path for developers to integrate arbitrary
      components, and they don't need to include marimo libraries, since
      all they'll need to do is fire a custom event on interaction and
      react to a custom event on value updates.


## Alternatives considered


**Interactivity triggered on `elem.value` references.**

We considered triggering reactivity based on whether a cell references the `value`
attribute of a named UIElement, instead of just the unqualified name. While this
may have prevented some unneccessary re-runs, it is also harder to explain, doesn't
fit with marimo's refs and defs model (which doesn't track attributes),
and is incompatible with pointer traversal.


<table>
<th>UIElement's name is a ref</th>
<th>UIElement's value attribute is referenced</th>

<tr>
<td>Reruns the interacted with cell</td>
<td>Does not rerun the interacted with cell</td>
</tr>

<tr>
<td>Runs all cells that have name as a ref, even if they don't access its value.</td>
<td>Only runs cell if they access element's value.</td>
</tr>

<tr>
<td>Compatible with accessing UIElement's value without referencing the `value`
attr, such as via a cast or operator overload </td>
<td>Incompatible with accessing UIElement's value without referencing the
`value` attr.</td>
</tr>

<tr>
<td>Compatible with pointer traversal to discover unnamed UI elements.</td>
<td>Incompatible with pointer traversal to discover unnamed UI elements.</td>
</tr>

<tr>
<td>Easier to explain.</td>
<td>Easy to explain.</td>
</tr>
</table>

The only cost to relying on the name, instead of the value attribute, is
running cells that may not have needed to be rerun, especially including the
cell that was just interacted with. This can be a performance consideration
(which is okay), but it can also be a correctness consideration if the cell is
not idempotent, and was not meant to be rerun. However, in marimo, it is best
practice to make all cells idempotent.
If the refs are the same, you likely want to the defs and the output to be the
same.


**Never re-running the cell whose output was interacted with.** We considered
not re-running the cell whose output is interacted with, to prevent unnecessary re-runs
or surprising behavior. However, this is difficult to explain, and prevents
some legitimate use cases of having the interacted-with cell run.

**Manually binding names to UI elements.** We considered separating UI element
objects and their values into two separate entities, and providing an API to
bind objects to names at runtime. An early prototype showed
this to be very unwieldy as it often required naming both the element
and its value, like `input_field` and `input_value`. The syntax was also
unpythonic and difficult to explain.

**Rendering UI elements in iframes.** We considered rendering UI elements
elements as entire web pages in iframes, instead of shadow DOMs. The only
benefit we saw for this was tighter sandboxing, but this point was made moot
because we ultimately decided sandboxing was not necessary (see discussion in
previous section). The downsides were making messaging, resizing
logic, and instantantiation from Python all more complicated.
