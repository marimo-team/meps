---
MEP: 3
Title: UI elements
Discussion: XXX
Implementation: XXX
---

# UI Elements

## Abstract

This MEP lays out a design for creating user interface (UI) elements
as cell outputs, and synchronizing their value on the frontend and with the
kernel The main concerns of the design are:

- the concept of a UI element as an HTML element with a value
- syntax for accessing a UI element's value
- syncronizing a UI element's appearance when it is shown multiple times
  within an app
- synchronizing a UI element's value in the frontend with its value in the
  kernel
- a simple rule that determines which cells are run when a UI element is interacted with
- a simple mechanism for making custom elements

## Motivation

Marimo stands out from traditional paradigms for interactive computing in a few
important ways: it is *reactive*, functioning like a spreadsheet,
*interactive*, with UI elements rendered in one cell able to seamlessly control
the execution of other cells via reactivity, and *extensible*, with the ability
to make custom UI elements as well as make any Python object render as a UI
element. While some open-source libraries and commercial editing tools provide
subsets of this functionality in ad-hoc ways, to our knowledge no tool like
marimo (open-source or otherwise) exists for Python developers. In particular,
no tool provides a pure Python experience, in which both experiments and
applications are built using an extensible, modular, and composable programming
framework. Because UI elements are key to enabling both rapid experimentation
and app development, it is vital that they are carefully designed.

## Criteria
We strive for a design that is:

- *seamless*: accessing a UI element's value must be seamless; no callbacks
- *simple*: a simple rule should explain what cells are run when a UI element is interacted with
- *Pythonic*: creating, displaying, and reading UI elements should be Pythonic
- *no web programming*: 99% of users shouldn't need to write any HTML,
                        Javascript, or CSS
- *customizable*: styling of UI elements should be customizable with CSS
- *extensible*: it should be easy for developers to implement custom UI
  elements, using any web technology

## UI elements: HTML objects with values
A UI element is an HTML element that has a _value_.
Its value may change when interacted with.

### The `UIElement` type

A `UIElement` is a Python class representing an HTML element that has a value,
stored in a property called `value`. This value can be set at creation time by
the user, to designate a default value for the element. After creation, the
value cannot be changed by user code.

The `UIElement` class implements the `formatting.MIME` protocol, and its
`__mime__` method returns an output of type `text/html`.


The frontend can render the same `UIElement` multiple times, with multiple
instances of the same element tied together via a unique key (generated by
marimo on the user's behalf). These rendered elements may choose to update
their values at any time, but typically their values will only change upon user
interaction.

**Frontend synchronization.** When the value of a rendered `UIElement` changes,
all other instances of the element that are rendered in the frontend have their
value updated as well. This ensures that the frontend remains consistent.

**Kernel synchronization**. 
When a rendered `UIElement`s value changes, the frontend sends a value update
request to the kernel; the kernel is then responsible for updating the `value`
attribute on the Python object corresponding to the element. When this
happens, the kernel wil run certain cells that depend on the `UIElement`
object, enbling user interaction to drive execution of other cells.
The rule for which cells are run is described in the next section.

## Element library

The `marimo` library will ship with a library of pre-fabricated UI elements.
These elements will be made available through the module `marimo.ui`. Some
examples of basic elements include a numeric slider, number picker, text box,
checkbox, radio button and radio group, drop-down menu, file upload, and
button. Additional elements may include data structure elements, like a list,
dictionary, and set.

We defer the design of `marimo.ui` to a future MEP.

## A Runtime rule

A single rule determines which cells will run after a `UIElement` is interacted
with: any cell referring to one or more of the names bound to a `UIElement`
will be run whenever a UI Element sends a value to the kernel. By
"referring", we mean that the cell has a name bound to the element among its
_refs_.

### Examples
**A simple example.**

> cell a
```python
text = mo.ui.text()
text
```

> cell b
```python
text.value
```

> cell c
```python
str(text)
```

Interacting with the UI element in `cell a` will cause cells `b` and `c` to
run, since `text` is a name bound to the element, and cells `b` and `c` both
have `text` among its refs. Cell `a` will _not_ run, because it has `text`
among its defs, not its refs.

**Two bound names.**

> cell a
```python
text = mo.ui.text()
text_alias = text
text
```

> cell b
```python
text.value
```

> cell c
```python
text_alias.value
```

Interacting with element in `a` will cause cells `b` and `c` to
run, since `text` and `text_alias` are names bound to the same `UIElement` object.

**Constructor cells.**

An interaction will never cause a cell that creates the interacted-with
`UIElement` to run, since the constructing cell will never have the element's
name(s) among its refs.

This is an intended consequence of the ruleset, for if a cell that created the
`UIElement` were run upon interaction, then the `UIElement` would be
reconstructed and re-initialized with its default value, which would
effectively undo the effect of interacting with the element, making interaction
pointless. However, in some cases, the fact that constructor cells are not run may be surprising. For example:


> cell a
```python
# this cell won't do what its author wanted it to do ...
slider = mo.ui.slider(start=1, stop=10)
x = slider.value
```

> cell b
```python
slider
```

Interacting with the emitted slider will _not_ update the value of `x`. To
prevent confusion, we raise an exception at runtime when a
`UIElement`'s value is accessed in the cell that created it. In particular,
line `2` of cell `a` would raise an exception.

**Cells that reference and output a UI element.**

Let `element` be a `UIElement` in the cell

> cell a
```
element
```

Interacting with its output will trigger execution of `a`. In most cases this
execution will be unneeded, but harmless, since cells should be idempotent;
performance optimizations in the kernel and frontend can lessen the 
wasted computation (for example, we may choose to only send outputs to the
frontend when the output has changed).

In other cases, re-execution of the cell is in fact intended, as in cell `b` in
the below example:

> cell a
```python
text = mo.ui.text()
```

> cell b:
```python
contents = text.value
text, contents
```


**Unnamed `UIElement`s.**

If a `UIElement` does not have a name, then interacting with it will not
trigger execution of other cells, no matter where the element is used.

For example:

> cell a
```python
l = [mo.ui.text()]
l
```

> cell b
```python
l[0].value
```

Interacting with `l`'s stored text element in `cell a` will _not_ cause `cell
b` to run, because the text element is unnamed: `l[0]` is not a name bound to a
`UIElement` object, instead it is an expression that evaluates to a `UIElement`
at runtime.

_Traversing pointers?_
One might consider traversing pointers (via `gc.get_referrers()`) to discover
where unnamed `UIElement`s are used, and run those cells as well; however, this
may lead to what appears to be "action at a distance" when a `UIElement` is
heavily nested or hidden within the internals of some object. Moreover,
it is possible for `gc.get_referrers()` to miss some objects, if those
objects don't support garbage collection, though in practice this will rarely happen.

Given the extra complexity that traversing pointers would add to the ruleset
and implementation, we have decided against this path. Instead, we will provide
library functions that wrap common data structures. For example, the previous
example involving a list could be rewritten as

> cell a
```python
l = mo.ui.list([mo.ui.text()])
l
```

> cell b
```python
l.value[0]
```

Interacting with `l` would now execute `b`, as desired. If this proves
to be too cumbersome or confusing, depending on user feedback, we may consider extending the ruleset to
include unnamed UI elements.

## Implementation 

### The `ui-element` tag

We define a custom HTML tag, `<ui-element>`, for rendering and sychronizing
UI elements on the page and with the kernel; this tag is registered as a
custom element. A `<ui-element>` wraps a single container element at
which the UI element is root.

**Object ID.**
A `ui-element` has a single attribute, `object-id`, which
uniquely identifies a `UIElement` object in the Python kernel. There may
be multiple `<ui-elements>` on the page with the same object id if the same
element is shown multiple times on the page.

**Communication.** The `ui-element`'s child sends a custom event,
`marimo-value-input`, when its value has been updated:

```typescript
type marimoValueInputEventType = CustomEvent<{ value: any }>;
```

In response, the `<ui-element>` sends a `marimo-value-update` event
to all other objects sharing its object id to inform them that their values need
to be updated:

```typescript
type marimoValueUpdateEventType = CustomEvent<{ value: any }>;
```

It also sends a message to the kernel, informing it to send a value update
request to the Python kernel. The value is encoded as JSON before it is sent.

#### UI elements as custom web components

We implement the elements provided in `marimo.ui` as custom web components
(*e.g.*, `<marimo-slider start="1" stop="10" step="2"></marimo-slider>`)
that render their content in a shadow DOM. This has the following advantages:

- Styles are isolated from the editor.
- The implementation of the UI element is separate from the editor code
  and framework agnostic.
- UI elements are easily composed using slots.
- UI elements are easy to create from Python --- we send over
  an HTML tag with attributes encoding the arguments of the UI element, and the
  browser handles their instantiation on our behalf.
- Using web components provides a simple path for others to implement
  their own UI elements and register them with marimo, though care must be
  taken to ensure that no name is registered more than once.

**UI elements are not sandboxed.**
We note that UI elements are _not_ isolated from the main document: 
they may read and modify anything on the page, though in the vast majority of
cases it would be good practice for them to not do so. This is a conscious
choice, since the alternatives are either too restrictive (such as rendering
all UI elements in sandboxed iframes) or cumbersome (serving UI elements from
different origins). Ultimately, `marimo` embraces end-user programming, and
we don't want to impose undue limitations on what users can do.

Just as users must exercise judgment on whether a Python library is safe for
them to use, they must also make sure to only use UI elements that they trust.
Of course, if the user trusts `marimo`, then they can trust the elements in the
`marimo.ui` module. Care must be taken when deploying marimo apps to ensure
that CSRF attack vectors aren't present.



### The Python `UIElement` class

We introduce a `UIElement` class that wraps HTML text in a `<ui-element>` tag and
registers the element with the kernel. This class has a read-only property
`value` for accessing the element's current value.

To create a `UIElement`, one subclasses this class, build the HTML string
from constructor parameters, and optionally implements a `_set_value`
method that sets the value of the element given the result of parsing the JSON
value update. This API is not yet public.

For example, here is a prototype implementation of a text element:

```python
class text(UIElement):
    def __init__(self, value: str = "", label: str = "") -> None:
        super().__init__(
            build_web_component(
                component_name="marimo-text",
                initial_value=value,
                args={"label": label},
            ),
            value,
        )
```

And a more interesting implementation of a button element that optionally
executes an action on click :

```python
class button(UIElement):
    @staticmethod
    def _on_click_noop() -> None:
        return None

    def __init__(
        self,
        on_click: Callable[[], Any] = _on_click_noop,
        value: Optional[Any] = None,
        label: str = "click",
    ) -> None:
        self._on_click = on_click
        super().__init__(
            build_web_component(
                component_name="marimo-button",
                initial_value=None,
                args={"label": label},
            ),
            None,
        )

    def _set_value(self, value: Any) -> None:
        del value
        self._value = self._on_click()
```

**Registering custom elements.**
In a future MEP, we will introduce a mechanism for registering UI elements that
are implemented entirely outside Python. Once registered, these elements will
be able to integrated with Python by subclassing the `UIElement` class, just
like native `marimo.ui` elements.

## Evaluation

> - *seamless*: accessing a UI element's value must be seamless; no callbacks

- [x] an element's value is accessible through its `value` attribute

> - *simple*: a simple rule should explain what cells are run when a UI element is interacted with

- [x] one sentence: cells that ref the element's names are run

> - *Pythonic*: creating, displaying, and reading UI elements should be Pythonic

- [x] creating is just a function call, displaying is an output, reading a
      property read

> - *no web programming*: 99% of users shouldn't need to write any HTML,
                        Javascript, or CSS

- [x] `marimo.ui` provides premade elements

> - *customizable*: styling of UI elements should be customizable with CSS

- [x] web components styles are isolated from the editor; an element's Python
  constructor could take custom styles to pass on to the frontend.

> - *extensible*: it should be easy for developers to implement custom UI
  elements, using web technologies of their choice

- [x] web components provide a simple path for developers to integrate arbitrary
      components, and they won't need to include marimo libraries on the
      frontend, since all they'll need to do is fire a custom event on interaction
      and react to a custom event on value updates.


## Alternatives considered


**Interactivity triggered on `elem.value` references.**

We considered triggering reactivity based on whether a cell uses the `value`
attribute of a named `UIElement`, instead of just the unqualified name. While
this would prevent some unneccessary re-runs, it is also harder to
explain, doesn't fit with marimo's refs and defs model because attributes
aren't tracked, and is incompatible with pointer traversal.


<table>
<th>UIElement's name is a ref</th>
<th>UIElement's value attribute is used</th>

<tr>
<td>Reruns the interacted with cell</td>
<td>Does not rerun the interacted with cell</td>
</tr>

<tr>
<td>Runs all cells that have name as a ref, even if they don't access its value</td>
<td>Only runs cell if they access element's value</td>
</tr>

<tr>
<td>Compatible with accessing UIElement's value without referencing the `value`
attr, such as via a cast or operator overload </td>
<td>Incompatible with accessing UIElement's value without referencing the
`value` attr</td>
</tr>

<tr>
<td>Compatible with pointer traversal to discover unnamed UI elements</td>
<td>Incompatible with pointer traversal to discover unnamed UI elements</td>
</tr>

<tr>
<td>Easier to explain</td>
<td>Easy to explain</td>
</tr>
</table>


**Never re-running the cell whose output was interacted with.** We considered
not re-running the cell whose output is interacted with, to prevent unnecessary
re-runs or surprising behavior. However, this complicates the interaction rule
and prevents some legitimate use cases that require the interacted-with cell to
run.

**Manually binding names to UI elements.** We considered separating UI element
objects and their values into two separate entities, and providing an API to
bind objects to names at runtime. An early prototype showed
this to be very unwieldy as it often required naming both the element
and its value, like `input_ui_element` and `input_value`. The syntax was also
un-Pythonic and difficult to explain.

**Rendering UI elements in iframes.** We considered rendering UI elements
elements as entire web pages in iframes, instead of as document fragments in
shadow DOMs. The only benefit we saw for this was tighter sandboxing, but this
point was made moot because we ultimately decided sandboxing was not necessary
(see discussion in previous section). The downsides were making messaging,
resizing logic, and instantantiation from Python all more complicated.

## Future work

1. An API for registering custom UI elements.
2. An API for serializing the state of all UI elements to disk and loading
   serialized state from disk into a marimo session.
