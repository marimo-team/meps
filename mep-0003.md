---
MEP: 3
Title: UI elements
Discussion: XXX
Implementation: XXX
---

# UI Elements

## Abstract

This MEP lays out a design for a user interface (UI) module, `marimo.ui`, which
provides a library of pre-fabricated UI elements that programmers
can use in their apps. The main concerns of the design are:

- a UI element as an HTML element with a value
- synchronizing a UI element's value in the frontend with its value in the
  kernel
- syncronizing a UI element's appearance when it is shown multiple times
  within an app
- syntax for accessing a UI element's value
- extensibility, or how to make custom elements

## Motivation

Marimo stands out from traditional paradigms for interactive computing in a few
important ways: it is *reactive*, functioning like a spreadsheet,
*interactive*, with UI elements rendered in one cell able to seamlessly control
the execution of other cells via reactivity, and *extensible*, with the ability
to make custom UI elements as well as make any Python object render as a UI
element. While some open-source libraries and commercial editing tools provide
subsets of this functionality in ad-hoc ways, to our knowledge no tool like
marimo (open-source or otherwise) exists for Python developers. In particular,
no tool provides a pure Python experience, in which both experiments and
applications are built using an extensible, modular, and composable programming
framework.

## Criteria
Enabling data scientists to build powerful apps is one of marimo's twin
purposes. For this reason, it is critical that marimo's support for UI elements
is carefully designed.

We strive for a design that satisfies the following criteria:

- *seamless*: accessing a UI element's value must be seamless; no callbacks
- *Pythonic*: creating, displaying, and reading UI elements should be Pythonic
- *no web programming*: 99 percent of users shouldn't need to write any HTML,
                        Javascript, or CSS
- *extensible*: it should be easy for developers to implement custom UI
  elements, using web technologies of their choice

A big plus, but not a requirement for now, is the following:
- *customizable*: the styling of UI elements should be customizable

## UI elements: HTML objects with values
A UI element is an HTML element that has a _value_.
Its value may change when interacted with.

Many HTML elements do not have values; for example, markdown, or plain
text, or embedded videos, are just content. A UI element is different: for
example, a slider has a numeric value, a text form has a string value, and a
file upload box has a bytes value. This distinction is important enough to
merit the creation of a type specific to UI elements.

### The `UIElement` type

A `UIElement` is an `HTML` element that has a `value` attribute. This value can
be set at creation time by the user, to designate a default value for the
element; after creation, `value` cannot be changed by Python code.

**Frontend synchronization.** When the value of a rendered `UIElement` changes,
all other instances of the element that are rendered in the frontend have their
value updated as well. This ensures that the frontend remains consistent.

**Kernel synchronization**. Interacting with a rendered `UIElement` in the
frontend may change the `value` attribute on the Python object; when the value
is updated, every cell referencing the `UIElement` object is run reactively.
This enables interactivity to drive execution of other cells.

### Input elements

An important subclass of UI elements are the [HTML input
elements](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input).
These are UI elements the modern browsers provide out-of-the-box, and can be
constructed with just a few lines of HTML.

Every input element has a [value
attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#value)
that stores its current value; some have special attributes (such as 'checked'
for checkboxes) that contain additional information. An input event is fired
whenever the value is changed.

#### Library of included elements

**Slider.**

**Text.**

**Checkboxes.**

**Radio buttons.**

**File upload.**

XXX

### Other UI elements

There are many other kinds of UI elements that are not, however, input elements.
For example, a D3 visualization, an image with a bounding box selector, or
a webcam screenshotter are all UI elements but are not HTML input elements.
Their interactivity is not furnished by the browser, but by custom Javascript
code. Our design must have a path toward supporting these other elements.

XXX: implement in separate .js/.ts file, package into a library? write raw
HTML/javascript in python?

## Implementation

```python
class UIElement(Html):
  def __init__(self, text: str, initial_value: Optional[Any] = None) -> None:
    super().__init__(text)
    self._value = initial_value
    
  @property
  def value(self) -> Any:
    return self._value
```

XXX: instead of containing raw HTML, should the UI element just be a message
(args) that the _frontend_ uses to construct the UI element? eg, for a slider,
the UI element's mimetype could be vnd.marimo+ui+slider, and its value could 
JSON (or a protobuf, or whatever) with the min, max, step, etc. the frontend
would use these args to instantiate a react component. This would
make development, maintenance, and testing easier, especially for more
complicated elements whose implementations require javascript (writing
javascript in a string in Python is not fun). But it would make writing custom
UI elements harder ... 

XXX the above only matters for extensibility/customizability -- it's basically
a plugin model that will determine how people write custom UI elements. it's
probably easier to write complex elements in .js/.ts files ... simple elements
could be written as inline html/js.

## Evaluation

XXX
