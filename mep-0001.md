---
MEP: 1
Title: Representation as a Python File
Discussion: XXX
Implementation: https://github.com/marimo-team/prototype/tree/file_v01
---

# Representation of an App as a Python File

## Abstract

This MEP proposes a representation of Marimo apps as structured Python files.
The representation is legible and easily versionable through source control. It
is designed to allow importing Marimo apps as Python modules, to access cells,
names, or the DAG itself, while also functioning as an executable script. We
strive for a minimal representation with these constraints in mind.

## Motivation

Marimo apps are dataflow programs, implemented in Python and executed by the
`marimo` Python library. It makes sense for these apps to be stored on disk as
Python files.

We seek a representation that has the following properties, ordered from
most important to least:

1. git diff friendly
2. easy for humans to read
    1. Pythonic
    2. cell ordering (in column) or arrangement (in grid)
    3. cell names (given by user, or automatically generated)
    4. cell refs and defs
    5. dataflow structure
3. usable as a Python module
    1. for users to use ("remix") cells, names, or the entire graph in other
      Python programs
4. executable as a Python script



## Example

Three cells, in a program called "numerics". Each cells can be understood
as a map between references and definitions ("refs" and "defs").


<table>
  <th>
  cell
  </th>
  <th>
  refs
  </th>
  <th>
  defs
  </th>

  <tr style="background:white">
  <td>

  ```python
  import marimo as mo
  import numpy as np
  ```
  </pre>
  </td>

  <td>
  {}
  </td>

  <td>
  {mo, np}
  </td>
  </td>
  </tr>

  <tr>
  <td>

  ```python
  def matmul(X, Y):
    return np.matmul(X, y)
  ```
  </td>

  <td>
  {np}
  </td>
  <td>
  {matmul}
  </td>
  </tr>


  <tr style="background:white">
  <td>

  ```python
  Z = matmul(np.random.randn(4, 4), np.random.randn(4, 4))
  mo.md(f"You calculated {Z}")
  ```
  </td>

  <td>
  {matmul, mo, np}
  </td>
  <td>
  {Z}
  </td>
</table>

Saved to `numerics.py`:

```python
"""numerics

made with marimo
"""

import marimo


_marimo_version = 0.0.1


def _make_app():
    def a():
        import marimo as mo
        import numpy as np
        return mo, np

    def b(np):
        def matmul(X, Y):
            return np.matmul(X, Y)
        return matmul,

    def c(matmul, mo, np):
        Z = matmul(np.random.randn(4, 4), np.random.randn(4, 4))
        mo.md(f"You calculated {Z}")
        return Z,

    return marimo._make_app([b, c, a])


app = _make_app()


if __name__ == '__main__':
    app.run()
```

## Specification

A marimo file contains three names that will be used either internally by
the marimo library, or by users:

- `_marimo_version`: the version of marimo used to generate the app
- `app`: The only public facing attribute. The `app` object will be extended
  with methods and attributes that provide access to the app's cells & names.
  This object may also store data for internal use.
- (optional) `_unparsable_cells`: a tuple of
  - cell name (`str`)
  - cell index/position (`Number`)
  - cell contents (`str`)

for each cell that has a syntax error. This attribute is optional, and only
consumed internally.

### Organization
The module's code is organized in the following order:
- **Header.** A header with the name of the file; not used by marimo.
- **marimo version.** `_marimo_version`, the version of marimo used to generate
  the module
- **App construction function.** An internal function that defines the cell
  functions and constructs the app.
- **Syntax errors.** A list of cells with syntax errors, included only when at
  least one cell has a syntax error.
- **App definition.** Invocation to the make app function.
- **Main**: A main function that runs the app.

### Cells
Cells are included in the module as functions, defined in `_cells()`. A cell
function is a mapping from the cell's refs, which it takes as arguments, to its
defs, which it returns.

The body of the cell (excluding the return statement) must be formatted in
exactly the same way that the user's code was formatted in the frontend.

### App
The `app` object includes an internal member `_functions`, a list of the
functions used to make the app. This is used by the library to instantiate the
module. **This member must remain in future versions to ensure backward
compatibility.**

The `run` method executes the apps and returns its outputs (a dict mapping
cell name to output) and its defs (a dict mapping def name to value).

The `_make_app` function takes a Sequence of functions, with each
defining a cell and assumed to be in presentation order. It also takes
generic kwargs, for future extensions.

In the future the `app` object may be extended with public members, such as a
`functions` object that provides access to function defs that were defined
in refless cells (or at least cells whose only refs are imports), or a
`classes` object providing access to class defs, and code transformation
utilities (eg, to push refs such as imports down into a cell).

### Error Handling

A generated module must always be importable, even if it has errors, so that
the server can extract cell codes and load them into the editor.

There are two types of errors we handle.

**Cycles.**
A marimo dataflow graph with a cycle is ill-defined and cannot be executed.
For this reason, the generated `__main__` code raises an error if the program
has a cycle.

Cycles are documented in a comment. This comment is not used by `marimo`, and
is only provided for the user's benefit.

Example:

```python
"""your_app

made with marimo
"""

import marimo


_marimo_version = 0.0.1


def _make_app():
    def one(y):
        x = y
        return x,

    def two(x):
        y = x
        return y,

    def three(b):
        a = b
        return a,

    def four(a):
        b = a
        return b,

    return marimo._make_app([one, two, three, four])


app = _make_app()


if __name__ == '__main__':
    # the following cycles were detected:
    #    one-two
    #    three-four
    raise ValueError('This program has errors:'
        + '\n* at least one cycle among cells'
    )
```

**Syntax errors.**
Cells with syntax errors cannot be defined as functions (if they were, importing
the module would raise a SyntaxError exception). Instead, they are included
in the file within an array of tuples. The tuples have the minimal information
needed for the editor to load them:
- the cell name
- the cell index/location
- the cell's function body, as a string, with double quotes escaped


Example:

```python
"""your_errorful_app

made_with_marimo
"""

import marimo


_marimo_version = 0.0.1


def _make_app():
    def one():
        import numpy as np
        return np,

    def three():
        'all good'
        return

    return marimo._make_app([one, three])


_unparsable_cells = [
    (
        'two',
        1,
        """
        _ error
        """,
    ),
    (
        'four',
        3,
        """
        _ another_error
        _ and \"\"\"another\"\"\"
        """,
    ),
]


app = marimo._make_app()


if __name__ == '__main__':
    raise ValueError('This program has errors:'
        + '\n* at least one cell has a syntax error'
    )
```

### Running as a script
Executing a marimo generated Python file as a script will execute the DAG. This
isn't really useful on its own, unless the DAG includes lots of print
statements -- but that would be an anti-pattern, since standard out and
standard error are de-emphasized in marimo.

It could be useful if the generated HTML was printed to standard out, but it's
not clear that the generated HTML is useful outside the marimo frontend.

It could also be useful if `names` or "refless defs" (defs that do not depend
on refs) were lifted and made optional parameters of the main program, and if
the DAG interacted with the user's filesystem (e.g., saving files to disk). In
this case marimo apps could be stitched together using pipelining tools.

The `__name__` guarded section has some use as documentation of the DAG's
structure.

### Namespacing
The user can define two types of names:
- cell names
- all other names (a cell's "defs")

The specification takes care to avoid name clashes with user-defined names by
ensuring that user-defined names are never added to the generated code's
`globals`. All user-defined names are introduced in local scopes.

### Extensibility
The file must always export a `app` object, that at minimum has a `_functions`
attribute.

Additional functionality can be added by adding additional members to this
`app` object.

### Backwards Compatibility
The file format is guaranteed to be backwards compatible in the following
sense: marimo will always be able to open modules generated by older versions
of marimo, because all it needs are the cell functions (`app._functions`) and
syntax errors (`_unparsable_cells`).

Conversely, for as long as we only depend on these two names, marimo should be
forward compatible with modules generated by newer versions of marimo (i.e., 
an old version of marimo should be able to load a module generated by
a newer version).

The version of marimo used to generate the module is included in the header
in case a backward incompatible change is made. In this case, the version
of marimo that introduced the backward incompatible change should be bundled
with a loader that can read modules generated by older versions.

## Alternatives Considered

1. Explicitly defining the DAG, as sequence of function calls, under
   the `__main__` section. This was supposed to help readability, since
   it documents the graph; however, it ended up hurting readability
   because DAGs can become very verbose (due to the need for namespacing) and
   obtuse (when users don't name their cells, which will be the default).
   Moreover it was misleading because it suggested that sibling cells
   ran in a deterministic order, which is False.
2. A flat format in which the program was stored as a script, using comments
   to separate cells instead of encapsulating them in functions. This is
   a smaller representation than what we've proposed in this MEP, but it makes
   it unwieldy to use the script as a module.
3. Decorating each function with `@marimo.cell`, which transforms functions
   into structured Cell objects. We had initially planned for the cell functions
   to be symbolic, so that calling them would construct a symbolic DAG. But we
   don't have a use for this right now.


## Implementation

https://github.com/marimo-team/prototype/tree/file_v01

## Future Considerations

- Invoking a marimo app as a script with optional parameters (substituting for some or all refless defs)
- Invoking `app.run` with optional parameters (substituting for some or all refless defs)
- Do we want to support grid layouts? How?
- Communicating the DAG structure in a comment
- A tool (marimo app??) for visualizing the DAG
