---
MEP: 1
Title: Representation as a Python File
Discussion: XXX
Implementation: https://github.com/marimo-team/prototype/tree/file_v01
---

# Representation of an App as a Python File

## Abstract

This MEP proposes a representation of Marimo apps as structured Python files.
The representation is legible and easily versionable through source control. It
is designed to allow importing Marimo apps as Python modules, to access cells,
names, or the DAG itself, while also functioning as an executable script. We
strive for a minimal representation with these constraints in mind.

## Motivation

Marimo apps are dataflow programs, implemented in Python and executed by the
`marimo` Python library. It makes sense for these apps to be stored on disk as
Python files.

We seek a representation that has the following properties, ordered from
most important to least:

1. git diff friendly
2. easy for humans to read
    1. Pythonic
    2. cell ordering (in column) or arrangement (in grid)
    3. cell names (given by user, or automatically generated)
    4. cell refs and defs
    5. dataflow structure
3. usable as a Python module
    1. for users to use ("remix") cells, names, or the entire graph in other
      Python programs
4. executable as a Python script



## Example

Three cells, in a program called "numerics". Each cells can be understood
as a map between references and definitions ("refs" and "defs").


<table>
  <th>
  cell
  </th>
  <th>
  refs
  </th>
  <th>
  defs
  </th>

  <tr style="background:white">
  <td>

  ```python
  import marimo as mo
  import numpy as np
  ```
  </pre>
  </td>

  <td>
  {}
  </td>

  <td>
  {mo, np}
  </td>
  </td>
  </tr>

  <tr>
  <td>

  ```python
  def matmul(X, Y):
    return np.matmul(X, y)
  ```
  </td>

  <td>
  {np}
  </td>
  <td>
  {matmul}
  </td>
  </tr>


  <tr style="background:white">
  <td>

  ```python
  Z = matmul(np.random.randn(4, 4), np.random.randn(4, 4))
  mo.md(f"You calculated {Z}")
  ```
  </td>

  <td>
  {matmul, mo, np}
  </td>
  <td>
  {Z}
  </td>
</table>

Saved to `numerics.py`:

```python
import marimo

__generated_with = "0.0.1"
app = marimo.App()


@app.cell
def _():
    import marimo as mo
    import numpy as np
    return mo, np


@app.cell
def _(np):
    def matmul(X, Y):
        return np.matmul(X, Y)
    return matmul,


@app.cell
def calculate(matmul, mo, np):
    from other_app import _data
    Z = matmul(np.random.randn(4, 4), _data())
    mo.md(f"You calculated {Z}")
    return Z,


if __name__ == '__main__':
    app.run()
```

## Specification

A marimo file contains three names that will be used either internally by
the marimo library, or by users:

- `app`: The only public facing attribute. The `app` object will be extended
  with methods and attributes that provide access to the app's defs.
- (optional) `__generated_with`: the version of marimo used to generate the app
- (optional) `__unparsable_cells`: a tuple of
  - cell name (`str`)
  - cell index/position (`Number`)
  - cell contents (`str`)

for each cell that has a syntax error. This attribute is optional, and only
consumed internally. 

Because the module is a pure Python file, it may be formatted in any way the
user likes. Users should not rely on the ability to include arbitrary comments
and logic to marimo, because these will be overwritten if/when using the
frontend to save edits (on the other hand, they may safely rely on custom
contents if they only use `marimo run`).

### Organization
The module's code is organized in the following order:
- **Version.** `__generated_with`, the version of marimo used to generate
  the module
- **App.** A creation of an empty app.
- **Cells.** Definitions of cells as functions, decorated with
  `@app.cell`.
- **Syntax errors.** A list of cells with syntax errors, included only when at
  least one cell has a syntax error, and interleaved with cell definitions.
- **Main**: An `if __name__ == '__main__'` guarded section for running the app.

### Cells
Cells are included in the module as functions, decorated with `app.cell`. A cell
function is a mapping from the cell's refs, which it takes as arguments, to its
defs, which it returns.

Cells are defined in the order that they are arranged in the frontend.

The body of the cell (excluding the return statement) is dedented and pasted
verbatim into the frontend, meaning that all formatting is preserved.

Users may choose to name their cell functions, either in the frontend or
by directly editing the generated module. Cells which are left unnamed by the
user are given the placeholder name `_`. Named cells can be imported
by other scripts/libraries from the module top-level.

Cells have the following restrictions on their names:

- No cell can be named `app`.
- No cell can be named `marimo`.
- No cell can be named `_`.
- No cell can be named a reserved Python keyword.
- Names cannot begin with two underscores: these are reserved for future use
  by marimo's codegen and loader.

### App

**The `app` object has three members that must remain in future versions to
ensure backward compatibility:**
- `_functions`, a list of the functions used to make the app, used by
  the library to instantiate the module. 
- `_add_unparsable_cell`, used in the module to register cells that have syntax
  errors.
- `run`, which executes the apps and returns its outputs (a dict mapping cell
  name to output) and its defs (a dict mapping def name to value).

In the future the `app` object may be extended with additional public members,
such as a `functions` object that provides access to function defs that were
defined in refless cells (or at least cells whose only refs are imports), or a
`classes` object providing access to class defs, and code transformation
utilities (eg, to push refs such as imports down into a cell).

### Error Handling

A generated module must always be importable, even if it has errors, so that
the server can extract cell codes and load them into the editor.

There are two types of errors we handle.

**Cycles.**
A marimo dataflow graph with a cycle is ill-defined and cannot be executed.
For this reason, `app.run()` will raise an error if cycles are detected.

Cycles are documented in comments. These comment is not used by `marimo`, and
are only provided for the user's benefit.

Example:

```python
import marimo

_generated_with = "0.0.1"
app = marimo.App()


# error: this cell (0) is in a cycle with cell 1
@app.cell
def _(y):
    x = y
    return x,

# error: this cell (1) is in a cycle with cell 0
@app.cell
def _(x):
    y = x
    return y,

# error: this cell (2) is in a cycle with cell 3
@app.cell
def _(b):
    a = b
    return a,

# error: this cell (3) is in a cycle with cell 2
@app.cell
def _(a):
    b = a
    return b,


if __name__ == '__main__':
    app.run()
```

**Syntax errors.**
Cells with syntax errors cannot be defined as functions (if they were, importing
the module would raise a SyntaxError exception, making it impossible to load
the app in the marimo frontend). Instead, they are included
in the file via the function `_add_unparsable_cell`. This function takes
the cell's code as a string, and inserts it into an internal list that combines
valid cells and unparsable ones (so that the order of cells is preserved).

Example:

```python
import marimo

__generated_with = "0.0.1"
app = marimo.App()


@app.cell
def _():
    import numpy as np
    return np,


app._add_unparsable_cell(
    """
    _ error
    """
)


@app.cell
def _():
    'all good'
    return


app._add_unparsable_cell(
    """
    _ another_error
    _ and \"\"\"another\"\"\"
    """,
)


if __name__ == '__main__':
    app.run()
```

### Running as a script
Executing a marimo generated Python file as a script will execute the DAG. This
isn't really useful on its own, unless the DAG includes lots of print
statements -- but that would be an anti-pattern, since standard out and
standard error are de-emphasized in marimo.

It could be useful if the generated HTML was printed to standard out, but it's
not clear that the generated HTML is useful outside the marimo frontend.

It could also be useful if `names` or "refless defs" (defs that do not depend
on refs) were lifted and made optional parameters of the main program, and if
the DAG interacted with the user's filesystem (e.g., saving files to disk). In
this case marimo apps could be stitched together using pipelining tools.

The `__name__` guarded section has some use as documentation of the DAG's
structure.

### Namespacing

The names of cells are added to the cell's top-level namespace. This makes
it possible for users to import a cell directly from a module
(`from numerics import calculate`), at the cost of polluting the top-level
namespace.

The specification takes care to avoid name clashes with cell names. 
The specification reserves the the following names for itself:
- `marimo`
- `app`
- `_` (used for unnamed cells)
- any name starting with two underscores (used for internal variables)

Cells are forbidden from having the same name as a reserved name.

Because users can have arbitrary names, this means that should we wish
to add public names in the future, these names will have to be nested
under the `app` object.

### Extensibility
The file must always export a `app` object, that at minimum has the three
attributes mentioned in the `app` section.

Additional functionality can be added by adding additional members to this
`app` object, or by adding members whose names start with `__`. No other
global names may be added.

### Backwards Compatibility
The file format is guaranteed to be backwards compatible: marimo will always be
able to open modules generated by older versions of marimo, because all it
needs are the cell functions (`app._functions`) and the cells with syntax
errors (`_unparsable_cells`).

Conversely, for as long as we only depend on these two names, marimo should be
forward compatible with modules generated by newer versions of marimo (i.e., 
an old version of marimo should be able to load a module generated by
a newer version).

The version of marimo used to generate the module is included in the file
in case a backward incompatible change is made. In this case, the version
of marimo that introduced the backward incompatible change should be bundled
with a loader that can read modules generated by older versions.

## Evaluation

Evaluation against the criteria:

>   1. git diff friendly

Let's consider different kinds of modifications made to an app, and
the modifications that would be made to the generated module as a result.

<table>

  <th>
  modification to app
  </th>
  <th>
  modification to module
  </th>
  <th>
  clean diff?
  </th>

<tr>
<td>modify an existing cell</td>
<td>modification to a single function (body, signature, returns)</td>
<td>Y</td>
</tr>

<tr>
<td>move a cell (up or down)</td>
<td>
function moved to a different location in the file
</td>
<td>Y</td>
</tr>

<tr>
<td>rename a cell</td>
<td>
a function's name is changed
</td>
<td>Y</td>
</tr>

<tr>
<td>introduce a cycle</td>
<td>
comments are added
</td>
<td>Y</td>
</tr>

<tr>
<td>introduce a syntax error</td>
<td>
function replaced with a call to `_add_unparsable_cell`
</td>
<td>Sort of</td>
</tr>

 <tr>
<td>change marimo version</td>
<td>
version number in `__generated_with` changes
</td>
<td>Y</td>
</tr>
</table>

Verdict: clean diffs!

>   2. easy for humans to read
>       1. Pythonic

Yes, fairly Pythonic. Unnamed cells are a little cryptic, but it's
easy to get used to them.

>       2. cell ordering (in column) or arrangement (in grid)

Easy to read off, since cells are defined in presentation order.
_However, it is not obvious how to extend this format to grid in a way that
remains readable._

>       3. cell names (given by user, or automatically generated)

Easy to read off, and to distinguish between named and unnamed cells.

>       4. cell refs and defs

Easy to read off from signature and returns.

>       5. dataflow structure

Not at all evident. Would need to rely on an external program to visualize
the DAG, and even still it will be awkward to visualize DAGs with unnamed cells.

**Verdict:** Very readable on all accounts except for dataflow structure,
on which we totally fail.

>   3. usable as a Python module
>       1. for users to use ("remix") cells, names, or the entire graph in other
>         Python programs

**Verdict**: Passing grade. Cells are accessible at top-level, and remixing
APIs can be included in the future under the `app` object.

>   4. executable as a Python script

**Verdict**: Passing grade. Can execute with `python` directly.


## Alternatives Considered

- git friendly: names of cells do not change without reason
- user friendly: unnamed cells do not clash with user names
- can import cells from top-level (is that desirable?)
- very close to something that you could code up directly in vim ...
- has name restrictions: can't use `app`, `marimo` or anything starting with
  two underscores
- can get rid of naming restrictions on `marimo` and `underscores` by
  defining cells in namespace, at cost of not being able to import named cells
  from module:

```python
def _make_app():
    app = marimo._App()

    @app.cell
    def _():
        import marimo as mo
        import numpy as np
        return mo, np

    @app.cell
    def _(np):
        def matmul(X, Y):
            return np.matmul(X, Y)
        return matmul,

    @app.cell
    def calculate(matmul, mo, np):
        from other_app import _data
        Z = matmul(np.random.randn(4, 4), _data())
        mo.md(f"You calculated {Z}")
        return Z,

    return app
```


```python
"""a marimo app"""

import marimo


_marimo_version = 0.0.1


def _cells():
    def a():
        import marimo as mo
        import numpy as np
        return mo, np

    def b(np):
        def matmul(X, Y):
            return np.matmul(X, Y)
        return matmul,

    def c(matmul, mo, np):
        Z = matmul(np.random.randn(4, 4), np.random.randn(4, 4))
        mo.md(f"You calculated {Z}")
        return Z,

    return b, c, a


app = marimo._make_app([b, c, a])


if __name__ == '__main__':
    app.run()
```

- unnamed cells given names corresponding to their arrangement in the app
- no naming restrictions on cells ...
    - ... but user names can disrupt flow of unnamed cells (what if a user
      names their cell "b"?)

- renaming of all default-named cells between cell's old and new positions,
  because names are given by cell order
- function defintions may move around because topological sort's behavior difficult
  to make determnistic & sensible at the same time
    - right now it depends on insertion order into the DAG, which in turn
      depends on ordering within the cell array
    - it could instead rely on cell names, but that would 
      lead to shuffling of a lot of cells;
    - it could rely on hashing of cell bodies --- this would be stable under
      moving of cells, but not under editing, which would be worse!



1. Explicitly defining the DAG, as sequence of function calls, under
   the `__main__` section. This was supposed to help readability, since
   it documents the graph; however, it ended up hurting readability
   because DAGs can become very verbose (due to the need for namespacing) and
   obtuse (when users don't name their cells, which will be the default).
   Moreover it was misleading because it suggested that sibling cells
   ran in a deterministic order, which is False.
2. A flat format in which the program was stored as a script, using comments
   to separate cells instead of encapsulating them in functions. This is
   a smaller representation than what we've proposed in this MEP, but it makes
   it unwieldy to use the script as a module.
3. Decorating each function with `@marimo.cell`, which transforms functions
   into structured Cell objects. We had initially planned for the cell functions
   to be symbolic, so that calling them would construct a symbolic DAG. But we
   don't have a use for this right now.


## Implementation

https://github.com/marimo-team/prototype/tree/file_v01

## Future Considerations

- Invoking a marimo app as a script with optional parameters (substituting for some or all refless defs)
- Invoking `app.run` with optional parameters (substituting for some or all refless defs)
- Do we want to support grid layouts? How?
- Communicating the DAG structure in a comment
- A tool (marimo app??) for visualizing the DAG
