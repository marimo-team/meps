---
MEP: 8
Title: Top Level Function Serialization
Discussion: (see [background](#background))
marimo-version: 0.11.10
---

# Top level file serializationn

/// admonition | Heads up
This MEP also runs as a marimo notebook.

[![App link](https://img.shields.io/badge/mep%200008-made%20in%20marimo-34D058)](https://marimo.app/gh/marimo-team/meps/mep-0007?entrypoint=mep-0008.md)
///

## Abstract

marimo notebooks are Python files, which ideally allows them to be used like regular Python modules.
However, defining reusable functions in a notebook is cumbersome.
Users cannot not naturally define a top-level function and import it from the notebook;
instead they have to rely on marimoâ€™s internal cell API or other workarounds.
This proposal introduces `app.function` to enable natural, top-level function definitions within marimo notebooks that can be imported and used like normal Python functions.

## Motivation

Currently, if a user wants to share logic (e.g. a utility function) from a notebook, they face limitations.
The only straightforward way to reuse a function defined in a notebook cell was to run that notebook and possibly access the function via the app object or cell outputs, or use a low-level API to retrieve it.
`app.embed` is availible but this is targeted towards reusing outputs and not logic.
As is, to run a function defined by a notebook, the following pattern is required:

```python
from my_notebook import named_cell

def wrap_cell_function(cell, fn_name):
    _outputs, defs = cell.run()
    return defs[fn_name]

my_function = wrap_cell_function(named_cell, 'my_function')
my_function()
```

## Criteria

Ideally, the following should be enabled:

```python
from my_notebook import my_function

my_result = my_function()
```

Moreover the these criteria are ideal:

 - Should not be confusing to any level of user
 - Should be easy to maintain as a script and from the notebook interface
 - Should allow for library imports to be used within the function
 - Should be usable by other programs (e.g. pytest)

## Background

The work towards top-level functions has already seen a fair amount of progress.
 - Cells can be directly called if all the dependencies are provided: https://github.com/marimo-team/marimo/pull/3251
 - The `app.function` decorator is already implemented: https://github.com/marimo-team/marimo/pull/3755
 - top level imports allow `@app.function` to be useful: https://github.com/marimo-team/marimo/pull/3779
 - There are pytest specific tweaks for usage in testing: https://github.com/marimo-team/marimo/pull/3294


For reading and discussion up to this point, refer to the following conversations.

### Top-Level API Discussions:
- https://github.com/marimo-team/marimo/discussions/2288
- https://github.com/marimo-team/marimo/issues/2293
- https://github.com/marimo-team/marimo/issues/719

As is, marimo notebooks are serialized as:

```python
# Header comments are preserved.                    # | Header comments.

import marimo                                       # | marimo import

with marimo.import_guard():                         # | Import definitions (unsettled, see below)
    # These imports are auto-generated by marimo.   # |- Import copy
    # Try modifying the source cell definitions     # ||
    # opposed to the following block.               # ||
    import textwrap                                 # |- Import block
                                                    # ||
    import marimo as mo                             # ||


__generated_with = "0.0.0"                          # | Metadata
app = marimo.App(_toplevel_fn=True)                 # | App init


@app.cell                                           # | Body
def normal_cell():                                  # |- Cell definition
    # General cell as per normal marimo behavior.   # ||
    A = 1                                           # ||
    def_that_uses_imports()                         # ||
    return A                                        # ||
                                                    # |
                                                    # |
@app.function                                       # |- Function definition
# Doubles as a function definition and a cell.      # ||
def def_that_uses_imports():                        # ||
    return mo.md(testwrap.dedent(                   # ||
        "    Hello there!"                          # ||
    ))                                              # ||
                                                    # |
                                                    # |
@app.cell                                           # |- Duplicated imports
def import_cell():                                  # ||
    import marimo as mo                             # ||
    import textwrap                                 # ||
    return textwrap, mo                             # ||


if __name__ == "__main__":                          # | Footer
    app.run()                                       # |
```

Header, marimo import, metadata, and footer are preserved. Howwever, top level functions require a new `app.function` decorator in body, and top level imports in the new Import Definitions block.
This document is to facilitate the conversation around 3 remaining concerns required to remove the experimental flag `_toplevel_fn` flag:

1. [Communication](#communication)
2. [Serialization](#Serialization)
3. [Security](#Security)

<!---->
## Communication
<!---->
Communication comes down to 2 things: Docs and UX.

### Documentation
A cursory glance through the current documentation, and the only page disucssing the file format comes from [guides/editors](https://docs.marimo.io/guides/editor_features/watching/).
Additionally, there is the [file format tutorial]( https://marimo.app/?slug=8n55fd) which is a bit outdated.

Suggestions:
 - It seems reasonable to refresh the fileformat tutorial: (See work in progress https://marimo.app/l/0u57k9)
 - Update the editor feature page to meantion the new `app.function` feature
 - Create a new page discussing code reuse/ using marimo as a library

### User Experience
#### Script
The script UX is relative straight forward, since the user must know about the
functionality to utilize it. However, the top level imports may be confusing
to some, and the import copy may need work. The intent of the copy is to 1.
disuade users from editing the block, and 2. make it clear that marimo files
can still be edited.

#### Editor
Top level function changes, having visual indication in script form, need a visual indicator in the editor.
There are 2 categories in how we can communicate top level function information in the editor:

#### Unmanaged

The criteria for `@app.function` serialization is:
1. Only imported references, or other toplevel function references are allowed.
2. the cell must only contain a single function definition.

If the function meets the criteria, then serialization in `app.function` form automatically occurs.
This UX is "unmanaged" because it does not require user input.
This is currently how `app.function` is implemented, but there is no visual indicator in the editor.

Benefits:
 - Implicit conversion means one less step if defining a library
 - No confusion pitfalls to new users since it does not impact the normal notebook behavior.

Disadvantages:
 - User wants to define a function a top-level function, but cannot this may
   cause frustration, this can be mitigated by showing a warning if a cell is
   close to being a top-level function, but not quite there.

**Suggestion**:

Show the function in output if it is standalone:

![Shows open code](https://github.com/user-attachments/assets/ca04c490-59dc-4f7c-8324-766af771620e)

Add a tooltip by definition if the function does not meet criteria:

![Shows tooltip on lambda](https://github.com/user-attachments/assets/2dd64ef8-8727-42ad-ac40-71495e4c3afb)

Allow `hide_output` on the cell level.

````python {.marimo hide_output=true}
mo.md(
    r"""
    <details>
    <summary>
    ```python
    def increment(val: int) -> int:
    ```
    </summary>
    ```python
        '''Adds one to an integer

        Args:
          val: int

        Returns:
          val + 1
        '''
    ```
    </details>
    """
)
````

#### Managed

marimo currently has special cells on the front end.
A "managed" UX would defer the special cell type to the user.
However, unlike md or sql special cells, the function signature and body is part of the resultant serilization, and it's possible to create invalid cells.

As such, marimo must prevent the user from saving in "function mode" if the body is invalid.
Similar to how app.unparsable works, an invalid function block may get serialized as:
```python
@app.unparsable_function("""
def my_function() # no colon for example
    pass
print(1) # or statements out of the function block
""")
```

Benefits:
 - User has explicit control of `app.function`

Disadvantages:
 - Inexperienced users may get stuck in the mode, and not understand why the
   cell doesn't run.
 - Possible to save a function with a reference to something else in the
   notebook, which will cause a name error when actually run. This could
   be mitigated by a warning when saving, but also just be confusing.
 - Additional metadata on the cell level to distinguish between the two modes.


UX Suggestion:

![shows option to move to function mode](https://github.com/user-attachments/assets/8618816c-2a3e-4e3b-b3dd-776f3c354bc2)


Just another "mode":

![shows function mode](https://github.com/user-attachments/assets/3d0ebef5-e2e2-40a5-99c1-fccc220627f3)

---

Suggestion:
 - Let's stick to unmanaged for now, it's consistent with how md and sql cells work.

<!---->
## Serialization
<!---->

As noted above, the import block serialization is not yet settled.
Here were a couple of suggestions:

### Comment Seperator

```python
# These imports are auto-generated by marimo.
# Try modifying the source cell definitions,
# opposed to the following block.
import pytest

import marimo

__generated_with = "0.0.0"
# ...
```

Link working implementation [and relevant test](https://github.com/marimo-team/marimo/pull/3779/files/db9d2578625f7b9d39d3dafa27b85d4329a81673#diff-339016dabb337751a0636e1c054e0fb97a11a6dd09185845dde365f47652b3d3R3-R8)

pros:
 - Looks nice
 - No linter issues

cons:
 - import order does not ensure marimo is first on format
 - brittle detection

### if seperator

```python
import marimo

if marimo.import_guard():
    # This section is auto-generated by marimo.
    import io
    import textwrap
    import marimo as mo
    import typing
    from pathlib import Path

__generated_with = "0.0.0"
```

Link working implementation [and relevant test](https://github.com/marimo-team/marimo/pull/3779/commits/7db678f9754dde74d8de3552dec6fd4f531bc1dc#diff-f0ce04493f0124e1c100939808ef5291bd6df9b32724091bbc9e360f29a6fb22R7-R15)

pros:
 - conditionally allow imports
 - easy to detect

cons:
 - all or nothing
 - some linters may complain that the imports may not be defined.

### `with` seperator

```python
import marimo

with marimo.import_guard():
    # These imports are auto-generated by marimo.
    # Try modifying the source cell definitions
    # opposed to the following block.
    import pytest

__generated_with = "0.0.0"
```


Link working implementation [and relevant test]( https://github.com/marimo-team/marimo/pull/3779/commits/36aa98e56daf687d4d89115e409dc744cdd9a0b3#diff-f0ce04493f0124e1c100939808ef5291bd6df9b32724091bbc9e360f29a6fb22R7-R17)

pros:
 - granuarly allow imports
 - easy to detect

cons:
 - `with` block skips are a bit of a hack, and may be confusing.
 - some linters might complain about shadowed/ duplicate imports

Possibility for marimo plugins

### Security

Allowing external imports prior to runtime initizalization is a security risk.
The `with` block allows some mitigation of this, by potentially selectively allowing imports,
but in the comment guard and if block, the imports are always allowed.

Suggestion:
marimo should move to a static analysis model of runtime initialization for edit mode.
Long term, if marimo ever does want to support plugins, a user config flag with a security explaination, could enable the module load behavior.
In this case, the `with` context block could still be used to limit imports.

currently you can `marimo edit` any script, and have the
top level definitions execute because marimo really is "just python"., but
serilizing to a state where an import could prevent runtime is a security risk.

This does make it potentially a breaking change if users have been capitalizing on this behavior.
<!---->
## Other top level definitions

### Classes

This seems totally reasonable with the same constraints as functions.
Suggestion `@app.class_definition`

### Constants
The prposal here is to put it in another module.

Easy opf top lvel imports is because the grundwork for 'import only cells' is already in place.
While static detection of a constant only cell is possible, the boundary between what is accetpable and what is not is not clear.
For instance:
```python
CONST = 1
```

but is

```python
CONST = 1
OTHER = 3
DEP = CONST + OTHER
```

the latter seems reasonable since it is only using primitives/ primitive operations
lists, which are mutable.
Plus, there's no such thing as true constants in python (reassignment being possible).

Moreover, constants are imported from other modules frequently, and seems like behavior this would want to support.
Exposing imports top level is OK- because while it is possible to indirectly import a value, it is highly discouraged.

suggestion: leave as is, to maintain simplicity and avoid confusion.

### import blocks

Currently, import blocks are implicitly a special cell type.
It makes sense that marimo would want to denote this with a like follows:

```python
@app.imports
def my_imports():
    import os
    import sys
    return os, sys
```

However, the implementation of this would have the exact same behavior as cells.
It also doesn't enable any new functionality.

```python {.marimo}
import this
```

> There should be one-- and preferably only one --obvious way to do it.


Basically syntatic sugar with no added value.
<!---->
## Alternatives Considered

An alternate suggestion was to import the entire notebook module and access the function via a cell name (e.g. import my_notebook; my_notebook.my_cell.my_function).
I don't think that toplevel functions discounts this. there are reasonable cases where this may be useful:
<!---->
## Future?

Top level functions could tidy up the notebook interface for expose to other "flask"-type applications like fastapi.
Consider:

```python
with marimo.import_guard():
    import marimo.fastapi_adapter as fa # maybe external plugin allowed too?

@app.function
@fa.get("/api/v1/my_function")
def my_function():
    return "Hello there!"
```

or even with the current proposed [MCP api](https://github.com/marimo-team/marimo/pull/3680/files#diff-f808acbb35cb39cd3754ac18b8ffa4ffe9ff12630f53e9573fb218c48890b5bfR1):

```python
with marimo.import_guard():
    import marimo.mcp.servers.dynamic_namespace.my_server as server


@app.function
@server.tool()
def random_number():
    return random.randint(1, 100)


@app.function
@server.prompt()
def what_are_my_tools():
    return "List the tools i have"
```

Decoration at this level allows for the script level to be more expressive and more functional.
Where `python my_script.py --plugin=mcp|fastapi` could turn on plugin level behavior.

<!---->
## Imports

```python {.marimo}
import marimo as mo
```
